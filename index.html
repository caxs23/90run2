<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ëŒ€í™”ëŠ” ë„ˆë¬´ ë¶€ë‹´ìŠ¤ëŸ¬ì›Œ</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700;900&display=swap');

        :root {
            --primary-color: #4a90e2;
            --accent-color: #ff6b6b;
            --text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        /* --- Fix for Mobile Layout --- */
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        body {
            position: fixed;
            left: 0;
            top: 0;
            font-family: 'Noto Sans KR', sans-serif;
            background-color: #222;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        /* --- Layout Container --- */
        #game-container {
            position: relative;
            width: 100vw;
            height: 100%;
            overflow: hidden;
        }

        /* --- Background --- */
        #background {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-size: cover;
            background-position: center;
            z-index: 0;
            filter: brightness(0.6);
            transition: transform 0.2s ease-out;
        }

        /* --- UI Layers --- */
        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100%;
            z-index: 200;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            box-sizing: border-box;
        }

        #title-screen, #game-over-screen, #intro-screen, #ending-screen {
            background: rgba(0, 0, 0, 0.8);
            pointer-events: auto;
            text-align: center;
            color: white;
            padding: 40px 20px;
            backdrop-filter: blur(8px);
        }

        #intro-screen {
            display: none;
            opacity: 0;
            transition: opacity 1s ease-in-out;
            z-index: 250;
        }

        #intro-screen h2 {
            font-size: 1.1rem;
            line-height: 1.8;
            word-break: keep-all;
            max-width: 80%;
            font-weight: 400;
        }

        h1 {
            font-size: 2.2rem;
            font-weight: 900;
            margin-bottom: 12px;
            color: #fff;
            text-shadow: 0 0 15px var(--primary-color);
            line-height: 1.2;
        }

        .subtitle {
            font-size: 0.9rem;
            color: #ccc;
            margin-bottom: 30px;
            line-height: 1.6;
            max-width: 90%;
            word-break: keep-all;
        }

        button {
            background: linear-gradient(135deg, #6e8efb, #a777e3);
            border: none;
            padding: 12px 35px;
            font-size: 1rem;
            color: white;
            border-radius: 50px;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
            cursor: pointer;
            transition: transform 0.1s;
            pointer-events: auto;
        }

        button:active {
            transform: scale(0.95);
        }

        button:disabled {
            background: #555;
            cursor: not-allowed;
            box-shadow: none;
            opacity: 0.6;
        }

        /* --- Loading Bar --- */
        #loading-container {
            width: 200px;
            height: 10px;
            background: #333;
            border-radius: 5px;
            margin-top: 20px;
            overflow: hidden;
            display: block;
        }
        #loading-bar {
            width: 0%;
            height: 100%;
            background: var(--primary-color);
            transition: width 0.1s;
        }
        #loading-text {
            font-size: 0.8rem;
            margin-top: 8px;
            color: #aaa;
        }

        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: auto;
            pointer-events: none;
            display: none;
            flex-direction: row;
            justify-content: space-between;
            align-items: flex-start;
            padding: 20px;
            box-sizing: border-box;
            z-index: 210;
        }

        #score-board {
            color: white;
            font-size: 0.9rem;
            font-weight: bold;
            background: rgba(0,0,0,0.6);
            padding: 8px 16px;
            border-radius: 20px;
            display: flex;
            align-items: center;
            gap: 8px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255,255,255,0.1);
            pointer-events: auto;
        }

        #lives-container {
            font-size: 1.4rem;
            margin-top: 5px;
            filter: drop-shadow(0 0 5px rgba(255,0,0,0.5));
        }

        /* --- Game Objects --- */
        #player {
            position: absolute;
            bottom: -100px; 
            left: 50%;
            transform: translateX(-50%);
            width: 600px; 
            height: 600px;
            z-index: 100;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center bottom;
            transition: transform 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
            filter: drop-shadow(0 10px 30px rgba(0,0,0,0.8));
        }

        .player-exit {
            transition: transform 3s ease-in, opacity 3s ease-in !important;
            transform: translateX(-50%) translateY(-200px) scale(0) !important;
            opacity: 0;
        }

        .enemy {
            position: absolute;
            bottom: 45%; 
            left: 50%;
            width: 300px;
            height: 300px;
            transform-origin: bottom center;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: bottom center;
            z-index: 50;
            will-change: transform, bottom, opacity;
        }

        .bubble {
            position: absolute;
            background: white;
            color: #333;
            padding: 10px 18px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 150;
            pointer-events: none;
            border: 2px solid #333;
            max-width: 65vw;
            white-space: pre-wrap;
            text-align: center;
        }

        .enemy-bubble {
            top: -80px;
            left: 50%;
            transform: translateX(-50%);
        }

        .player-bubble {
            top: 180px; 
            left: 50%;
            transform: translateX(-50%);
            border-color: #ff6b6b;
            color: #ff6b6b;
            animation: shake 0.3s ease-in-out;
            font-size: 1.1rem;
            z-index: 250;
        }

        @keyframes shake {
            0%, 100% { transform: translateX(-50%) rotate(0deg); }
            25% { transform: translateX(-50%) rotate(-3deg); }
            75% { transform: translateX(-50%) rotate(3deg); }
        }

        #game-over-screen, #ending-screen {
            display: none;
        }

        .damage-effect {
            position: absolute;
            top:0; left:0; width:100%; height:100%;
            background: red;
            opacity: 0;
            pointer-events: none;
            z-index: 300;
            transition: opacity 0.1s;
        }

        .invincible {
            animation: blink 0.2s infinite;
        }

        @keyframes blink {
            0% { opacity: 1; }
            50% { opacity: 0.3; }
            100% { opacity: 1; }
        }

        #ending-btn-container {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 500;
            display: none;
        }

        #ending-btn {
            background: linear-gradient(135deg, #43e97b, #38f9d7);
            color: #333;
            padding: 15px 40px;
            font-size: 1.2rem;
            border-radius: 30px;
            box-shadow: 0 0 20px rgba(67, 233, 123, 0.5);
        }

    </style>
</head>
<body>

    <div id="game-container">
        <div id="background"></div>
        <div id="world">
            <div id="player"></div>
        </div>
        <div id="damage-overlay" class="damage-effect"></div>

        <div id="hud" class="ui-layer">
            <div style="display: flex; flex-direction: column; align-items: flex-start; gap: 5px;">
                <div id="score-board" onclick="Game.checkDevRoute()">
                    <span>ğŸƒ í”¼í•œ ëŒ€í™”:</span>
                    <span id="score-val">0</span>
                </div>
                <div id="lives-container">
                    â¤ï¸â¤ï¸â¤ï¸
                </div>
            </div>
            <div id="back-btn-container">
                <button id="back-btn" style="background: rgba(0,0,0,0.4); border: 1px solid rgba(255,255,255,0.3); padding: 8px 16px; border-radius: 20px; color: white; cursor: pointer; pointer-events: auto; font-size: 0.8rem;" onclick="Game.resetToTitle()">ë©”ë‰´ë¡œ</button>
            </div>
        </div>

        <div id="ending-btn-container">
            <button id="ending-btn" onclick="Game.triggerEndingSequence()">í‡´ê·¼í•˜ê¸°!</button>
        </div>

        <div id="title-screen" class="ui-layer">
            <h1>ëŒ€í™”ëŠ”<br>ë„ˆë¬´ ë¶€ë‹´ìŠ¤ëŸ¬ì›Œ</h1>
            <div class="subtitle">
                ì¢Œìš° ìŠ¤ì™€ì´í”„ë‚˜ ë°©í–¥í‚¤ë¥¼ ì‚¬ìš©í•˜ì—¬<br>
                ë‹¤ê°€ì˜¤ëŠ” ì‚¬ëŒë“¤ì˜ ë¶€ë‹´ìŠ¤ëŸ¬ìš´ ëŒ€í™”ë¥¼ í”¼í•˜ì„¸ìš”!
            </div>
            
            <button id="start-btn" disabled onclick="Game.startIntro()">ë¡œë”© ì¤‘...</button>
            
            <div id="loading-container">
                <div id="loading-bar"></div>
            </div>
            <div id="loading-text">ë¦¬ì†ŒìŠ¤ ì¤€ë¹„ ì¤‘... (0%)</div>
        </div>

        <div id="intro-screen" class="ui-layer">
            <h2>"ë‚˜ëŠ” ê·¹ Iì´ê¸° ë•Œë¬¸ì— ëŒ€í™”ê°€ ë„ˆë¬´ ë¶ˆí¸í•˜ë‹¤!<br>ì˜¤ëŠ˜ë„ ì‚¬ëŒë“¤ì„ ì—´ì‹¬íˆ í”¼í•´ë‹¤ë…€ì•¼ì§€!"</h2>
        </div>

        <div id="game-over-screen" class="ui-layer">
            <h1 style="color: #ff6b6b; font-size: 2.2rem;">ê²°êµ­ ë¶™ì¡í˜”ë‹¤!</h1>
            <div class="subtitle">
                ê¸°ë¥¼ ë‹¤ ë¹¨ë ¸ìŠµë‹ˆë‹¤...<br>
                ê²°êµ­ ë°€ë ¤ë“œëŠ” ëŒ€í™”ì— ì •ì‹ ì„ ìƒê³  ë§ì•˜ìŠµë‹ˆë‹¤..
            </div>
            <div class="subtitle">
                íšŒí”¼ ê¸°ë¡: <span id="final-score" style="color:#ffeb3b; font-weight:bold; font-size: 1.4rem;">0</span>íšŒ
            </div>
            <button onclick="Game.restart()">ë‹¤ì‹œ ë„ë§ê°€ê¸°</button>
        </div>

        <div id="ending-screen" class="ui-layer">
            <h1 style="color: #43e97b; font-size: 2.2rem;">ì˜¤ëŠ˜ë„ ìŠ¤í…Œì´ë¸”í•˜ê²Œ<br>ë¬´ì‚¬íˆ í‡´ê·¼í–ˆë‹¤!</h1>
            <div class="subtitle">
                ì™„ë²½í•œ í•˜ë£¨ì˜€ìŠµë‹ˆë‹¤.<br>
                ì§‘ì— ê°€ì„œ ì–¼ë¥¸ ì¹¨ëŒ€ë¡œ ë“¤ì–´ê°€ì•¼ì§€!
            </div>
            <button onclick="Game.resetToTitle()">ë‹¤ì‹œ ì‹œì‘</button>
        </div>
    </div>

    <script>
        const toRaw = (url) => url.replace('github.com', 'raw.githubusercontent.com').replace('/blob/', '/');

        const ASSETS = {
            run: toRaw('https://github.com/caxs23/90run/blob/main/run.gif'),
            dodgeLeft: [
                toRaw('https://github.com/caxs23/90run/blob/main/left%20(1).png'),
                toRaw('https://github.com/caxs23/90run/blob/main/left%20(2).png'),
                toRaw('https://github.com/caxs23/90run/blob/main/left%20(3).png'),
                toRaw('https://github.com/caxs23/90run/blob/main/left%20(4).png')
            ],
            dodgeRight: [
                toRaw('https://github.com/caxs23/90run/blob/main/right%20(1).png'),
                toRaw('https://github.com/caxs23/90run/blob/main/right%20(2).png'),
                toRaw('https://github.com/caxs23/90run/blob/main/right%20(3).png')
            ],
            dodgeSounds: [
                toRaw('https://github.com/caxs23/90run/blob/main/dodge%20(1).mp3'),
                toRaw('https://github.com/caxs23/90run/blob/main/dodge%20(2).mp3'),
                toRaw('https://github.com/caxs23/90run/blob/main/dodge%20(3).mp3'),
                toRaw('https://github.com/caxs23/90run/blob/main/dodge%20(4).mp3')
            ],
            npc: {
                ceo: [toRaw('https://github.com/caxs23/90run/blob/main/ceo.png')],
                prof: [
                    toRaw('https://github.com/caxs23/90run/blob/main/prof%20(2).png'),
                    toRaw('https://github.com/caxs23/90run/blob/main/prof%20(3).png'),
                    toRaw('https://github.com/caxs23/90run/blob/main/prof%20(4).png'),
                    toRaw('https://github.com/caxs23/90run/blob/main/prof%20(5).png')
                ],
                patient: [
                    toRaw('https://github.com/caxs23/90run/blob/main/patient%20(1).png'),
                    toRaw('https://github.com/caxs23/90run/blob/main/patient%20(2).png'),
                    toRaw('https://github.com/caxs23/90run/blob/main/patient%20(3).png'),
                    toRaw('https://github.com/caxs23/90run/blob/main/patient%20(4).png')
                ],
                worker: [toRaw('https://github.com/caxs23/90run/blob/main/worker.png')]
            },
            bg: [
                toRaw('https://github.com/caxs23/90run/blob/main/hospital%20(1).jpg'),
                toRaw('https://github.com/caxs23/90run/blob/main/hospital%20(2).jpg'),
                toRaw('https://github.com/caxs23/90run/blob/main/hospital%20(3).jpg')
            ]
        };

        const DIALOGUES = {
            patient: ["ì„ ìƒë‹˜ ì € ì§‘ì— ê°€ê³  ì‹¶ì–´ìš”.", "ì‹¬ì‹¬í•´ìš”. ë†€ì•„ì¤˜ìš”.", "ì•ˆì•„ì¤˜ìš”.", "ì—¬ê¸´ ì™œ ë‹´ë°°ë¥¼ ëª» í´ìš”?", "ë°° ì•„í”ˆë° ë³€ì´ ì•ˆ ë‚˜ì™€ìš”.", "ë§ˆìŠ¤í¬ ë²—ì–´ì£¼ì„¸ìš”.", "í•¸ë“œí° ì“°ê³ ì‹¶ì–´ìš”."],
            prof: ["ë³‘ë™ì€ ìš”ì¦˜ ì–´ë–¤ê°€ìš”? í—ˆí—ˆ.", "ìƒˆë¡œìš´ í™˜ìë¥¼ ë³´ë‚´ë ¤ê³  í•˜ëŠ”ë°ìš”.", "ë³‘ë™ ì˜ê²¬ì€ ì–´ë–»ìŠµë‹ˆê¹Œ?", "ìˆ˜ê³ ê°€ ë§ìœ¼ì‹œë„¤ìš”.", "íšŒì§„í•˜ë‹¤ê°€ í•œ ëª… ë¹¼ë¨¹ì–´ì„œ ë‹¤ì‹œ ì™”ìŠµë‹ˆë‹¤.", "ë©´ë‹´ì€ ë©´ë‹´ì‹¤ì—ì„œ í•˜ê² ìŠµë‹ˆë‹¤."],
            ceo: ["ë‹¤ë“¤ ìˆ˜ê³ ê°€ ë§ìŠµë‹ˆë‹¤.", "ì´ê³³ì´ ë³´í˜¸ë³‘ë™ì´êµ°ìš”.", "ì—¬ê¸°ê°€ 90ë³‘ë™ì…ë‹ˆê¹Œ?"],
            worker: ["ì•„-í•˜.", "ì°¸ì¹˜ ë¨¹ìœ¼ëŸ¬ ê°‘ì‹œë‹¤!", "ì­ˆê¾¸ë¯¸ ë¨¹ìœ¼ëŸ¬ ê°‘ì‹œë‹¤!", "ì´ë²ˆì— í˜„ëŒ€ë°”ì´ì˜¤ê°€..", "ì–¼ë¥¸ í•˜ê³  ì‰½ì‹œë‹¤!"]
        };

        const PLAYER_HURT_DIALOGUES = ["ìœ¼ì•… ì‹«ì–´ìš”!", "ì•—! ë¶€ë‹´ìŠ¤ëŸ¬ì›Œ!", "ì•ˆë¼! ëŒ€í™”ë‹¹í–ˆì–´!", "ì‚´ë ¤ì£¼ì„¸ìš”!", "ë§ ê±¸ì§€ ë§ˆì„¸ìš”!"];
        const PLAYER_IDLE_DIALOGUES = ["ë¶ˆí¸í•œ ëŒ€í™”ëŠ” ì‚¬ì ˆì´ì•¼!", "ì˜¤ëŠ˜ë„ ìŠ¤í…Œì´ë¸”!", "ì–¼ë¥¸ ì§‘ì— ê°€ì•¼ì§€!"];

        const Game = {
            state: 'title',
            score: 0,
            lives: 3,
            lastFrameTime: 0,
            spawnTimer: 0,
            spawnInterval: 4500,
            enemies: [],
            player: {
                el: null,
                isDodging: false,
                dodgeDirection: null,
                dodgeTimer: null,
                invincible: false,
                invincibleTimer: null,
                isBubbleActive: false
            },
            worldEl: null,
            touchStartX: 0,
            
            lastHurtTime: 0,
            lastEnemyType: null,
            lastEnemyDialogue: {}, 
            lastPlayerHurtDialogue: null,
            lastPlayerIdleDialogue: null,

            playStartTime: 0,
            endingBtnShown: false,
            devClickCount: 0,

            audioCache: [],
            assetsToLoad: [],
            assetsLoaded: 0,

            init() {
                this.worldEl = document.getElementById('world');
                this.player.el = document.getElementById('player');
                
                // ë¡œë”© ë¦¬ìŠ¤íŠ¸ ì‘ì„±
                this.prepareAssetList();
                this.loadAllAssets();

                document.addEventListener('touchstart', (e) => { this.touchStartX = e.touches[0].clientX; });
                document.addEventListener('touchend', (e) => {
                    if (this.state !== 'playing') return;
                    const diffX = e.changedTouches[0].clientX - this.touchStartX;
                    if (Math.abs(diffX) > 40) this.dodge(diffX < 0 ? 'left' : 'right');
                });
                
                document.addEventListener('keydown', (e) => {
                    if (this.state !== 'playing') return;
                    if (e.key === 'ArrowLeft') this.dodge('left');
                    else if (e.key === 'ArrowRight') this.dodge('right');
                });
            },

            prepareAssetList() {
                // ì´ë¯¸ì§€ ëª¨ìœ¼ê¸°
                this.assetsToLoad.push({ type: 'img', url: ASSETS.run });
                ASSETS.dodgeLeft.forEach(u => this.assetsToLoad.push({ type: 'img', url: u }));
                ASSETS.dodgeRight.forEach(u => this.assetsToLoad.push({ type: 'img', url: u }));
                ASSETS.bg.forEach(u => this.assetsToLoad.push({ type: 'img', url: u }));
                Object.values(ASSETS.npc).forEach(list => {
                    list.forEach(u => this.assetsToLoad.push({ type: 'img', url: u }));
                });
                // ì‚¬ìš´ë“œ ëª¨ìœ¼ê¸°
                ASSETS.dodgeSounds.forEach(u => this.assetsToLoad.push({ type: 'audio', url: u }));
            },

            loadAllAssets() {
                const total = this.assetsToLoad.length;
                if (total === 0) {
                    this.onAllAssetsLoaded();
                    return;
                }

                this.assetsToLoad.forEach(asset => {
                    if (asset.type === 'img') {
                        const img = new Image();
                        img.onload = () => this.assetItemLoaded();
                        img.onerror = () => this.assetItemLoaded();
                        img.src = asset.url;
                    } else if (asset.type === 'audio') {
                        const audio = new Audio();
                        audio.oncanplaythrough = () => {
                            if (!audio.isCounted) {
                                audio.isCounted = true;
                                this.assetItemLoaded();
                            }
                        };
                        audio.onerror = () => this.assetItemLoaded();
                        audio.src = asset.url;
                        audio.load();
                        this.audioCache.push({ url: asset.url, audio: audio });
                    }
                });
            },

            assetItemLoaded() {
                this.assetsLoaded++;
                const percent = Math.floor((this.assetsLoaded / this.assetsToLoad.length) * 100);
                document.getElementById('loading-bar').style.width = percent + '%';
                document.getElementById('loading-text').innerText = `ë¦¬ì†ŒìŠ¤ ì¤€ë¹„ ì¤‘... (${percent}%)`;
                
                if (this.assetsLoaded >= this.assetsToLoad.length) {
                    this.onAllAssetsLoaded();
                }
            },

            onAllAssetsLoaded() {
                const btn = document.getElementById('start-btn');
                btn.disabled = false;
                btn.innerText = 'ë„ë§ì¹˜ê¸° ì‹œì‘';
                document.getElementById('loading-container').style.display = 'none';
                document.getElementById('loading-text').innerText = ''; // "ì¤€ë¹„ ì™„ë£Œ!" ë©”ì‹œì§€ ë¯¸í‘œì‹œ
                
                this.updatePlayerImage(ASSETS.run);
                this.setRandomBackground();
            },

            playRandomDodgeSound() {
                if (this.audioCache.length === 0) return;

                let selectedAudioObj;
                const dodge4Url = toRaw('https://github.com/caxs23/90run/blob/main/dodge%20(4).mp3');
                
                // 10% í™•ë¥ ë¡œ dodge(4).mp3 ì„ íƒ ì‹œë„
                if (Math.random() < 0.1) {
                    selectedAudioObj = this.audioCache.find(obj => obj.url === dodge4Url);
                }

                // ìœ„ ì¡°ê±´ì— í•´ë‹¹í•˜ì§€ ì•Šê±°ë‚˜ íŒŒì¼ì„ ëª» ì°¾ì€ ê²½ìš° ë‚˜ë¨¸ì§€ ì¤‘ì—ì„œ ëœë¤ ì„ íƒ
                if (!selectedAudioObj) {
                    const others = this.audioCache.filter(obj => obj.url !== dodge4Url);
                    if (others.length > 0) {
                        selectedAudioObj = others[Math.floor(Math.random() * others.length)];
                    } else {
                        // í˜¹ì‹œ ë¦¬ìŠ¤íŠ¸ì— (4)ë§Œ ìˆëŠ” ê²½ìš°ë¥¼ ìœ„í•œ í´ë°±
                        selectedAudioObj = this.audioCache[Math.floor(Math.random() * this.audioCache.length)];
                    }
                }
                
                const soundClone = selectedAudioObj.audio.cloneNode();
                soundClone.volume = 0.6;
                soundClone.play().catch(e => console.log("Audio play blocked."));
            },

            setRandomBackground() {
                const bgEl = document.getElementById('background');
                const rand = Math.floor(Math.random() * ASSETS.bg.length);
                bgEl.style.backgroundImage = `url('${ASSETS.bg[rand]}')`;
            },

            updatePlayerImage(src) {
                if (this.player.el) this.player.el.style.backgroundImage = `url('${src}')`;
            },

            startIntro() {
                const titleScreen = document.getElementById('title-screen');
                const introScreen = document.getElementById('intro-screen');
                
                titleScreen.style.display = 'none';
                introScreen.style.display = 'flex';
                
                setTimeout(() => { introScreen.style.opacity = 1; }, 50);
                
                setTimeout(() => {
                    introScreen.style.opacity = 0;
                    setTimeout(() => {
                        introScreen.style.display = 'none';
                        this.startGame();
                    }, 1000);
                }, 3000);
            },

            startGame() {
                this.state = 'playing';
                this.score = 0;
                this.lives = 3;
                this.enemies = [];
                this.spawnInterval = 5000 + Math.random() * 1000;
                this.lastHurtTime = performance.now();
                this.playStartTime = performance.now();
                this.endingBtnShown = false;
                this.devClickCount = 0;
                
                this.lastEnemyType = null;
                this.lastEnemyDialogue = {};
                this.lastPlayerHurtDialogue = null;
                this.lastPlayerIdleDialogue = null;
                
                this.updateScoreUI();
                this.updateLivesUI();
                this.setRandomBackground();
                
                document.getElementById('hud').style.display = 'flex';
                document.getElementById('game-over-screen').style.display = 'none';
                document.getElementById('ending-screen').style.display = 'none';
                document.getElementById('ending-btn-container').style.display = 'none';

                this.worldEl.innerHTML = '<div id="player"></div>';
                this.player.el = document.getElementById('player');
                this.player.el.classList.remove('player-exit');
                this.updatePlayerImage(ASSETS.run);
                this.player.isDodging = false;
                this.player.isBubbleActive = false;
                this.setInvincible(false, 0, false);
                
                this.lastFrameTime = performance.now();
                requestAnimationFrame((time) => this.gameLoop(time));
            },

            resetToTitle() {
                this.state = 'title';
                document.getElementById('hud').style.display = 'none';
                document.getElementById('game-over-screen').style.display = 'none';
                document.getElementById('intro-screen').style.display = 'none';
                document.getElementById('ending-screen').style.display = 'none';
                document.getElementById('ending-btn-container').style.display = 'none';
                document.getElementById('title-screen').style.display = 'flex';
                this.enemies.forEach(e => e.el.remove());
                this.enemies = [];
            },

            restart() {
                this.startGame();
            },

            gameOver() {
                this.state = 'gameover';
                document.getElementById('hud').style.display = 'none';
                document.getElementById('ending-btn-container').style.display = 'none';
                document.getElementById('final-score').innerText = this.score;
                document.getElementById('game-over-screen').style.display = 'flex';
            },

            checkDevRoute() {
                if (this.state !== 'playing') return;
                this.devClickCount++;
                if (this.devClickCount >= 5) {
                    this.showEndingButton();
                }
            },

            showEndingButton() {
                if (this.endingBtnShown) return;
                this.endingBtnShown = true;
                document.getElementById('ending-btn-container').style.display = 'block';
            },

            triggerEndingSequence() {
                this.state = 'ending';
                document.getElementById('ending-btn-container').style.display = 'none';
                document.getElementById('hud').style.display = 'none';
                
                this.enemies.forEach(e => {
                    e.el.style.opacity = '0';
                    setTimeout(() => e.el.remove(), 500);
                });
                this.enemies = [];

                this.player.el.classList.add('player-exit');

                setTimeout(() => {
                    document.getElementById('ending-screen').style.display = 'flex';
                }, 3000);
            },

            gameLoop(timestamp) {
                if (this.state !== 'playing') return;
                const deltaTime = timestamp - this.lastFrameTime;
                this.lastFrameTime = timestamp;

                if (!this.endingBtnShown && timestamp - this.playStartTime > 120000) {
                    this.showEndingButton();
                }

                const timeSinceLastHurt = timestamp - this.lastHurtTime;
                if (timeSinceLastHurt > 15000) {
                    this.showPlayerIdleDialogue();
                    this.lastHurtTime = timestamp; 
                }

                this.spawnTimer += deltaTime;
                if (this.spawnTimer > this.spawnInterval) {
                    this.spawnEnemy();
                    this.spawnTimer = 0;
                    this.spawnInterval = Math.max(3500, (4000 + Math.random() * 1000) - (this.score * 50));
                }

                this.updateEnemies(deltaTime);
                requestAnimationFrame((time) => this.gameLoop(time));
            },

            spawnEnemy() {
                const types = Object.keys(ASSETS.npc);
                
                // ê°€ì¤‘ì¹˜ë¥¼ í†µí•œ íƒ€ì… ì„ íƒ (ceo, workerëŠ” í™•ë¥  50% ê°ì†Œ)
                const weights = {
                    patient: 1.0,
                    prof: 1.0,
                    ceo: 0.5,
                    worker: 0.5
                };

                let weightedPool = [];
                types.forEach(type => {
                    // ì§ì „ ì ê³¼ ê²¹ì¹˜ì§€ ì•Šê²Œ í•„í„°ë§
                    if (type !== this.lastEnemyType) {
                        const count = weights[type] * 10; // ì •ìˆ˜í™”ë¥¼ ìœ„í•´ 10 ê³±í•¨
                        for (let i = 0; i < count; i++) {
                            weightedPool.push(type);
                        }
                    }
                });

                // ì§ì „ íƒ€ì… ì œì™¸í•˜ê³  í’€ì´ ë¹„ì—ˆìœ¼ë©´(ë¶ˆê°€ëŠ¥í•˜ê² ì§€ë§Œ) ì „ì²´ì—ì„œ ì„ íƒ
                if (weightedPool.length === 0) {
                    types.forEach(type => {
                        const count = weights[type] * 10;
                        for (let i = 0; i < count; i++) {
                            weightedPool.push(type);
                        }
                    });
                }
                
                const type = weightedPool[Math.floor(Math.random() * weightedPool.length)];
                this.lastEnemyType = type;

                const imgUrl = ASSETS.npc[type][Math.floor(Math.random() * ASSETS.npc[type].length)];
                const side = Math.random() < 0.5 ? 'left' : 'right'; 

                const enemyEl = document.createElement('div');
                enemyEl.className = 'enemy';
                enemyEl.style.backgroundImage = `url('${imgUrl}')`;
                this.worldEl.appendChild(enemyEl);

                const enemy = {
                    el: enemyEl,
                    type: type,
                    side: side, 
                    progress: 0, 
                    duration: 5000,
                    hasSpoken: false,
                    spawnTime: performance.now(),
                    collisionStarted: 0
                };
                this.enemies.push(enemy);
            },

            updateEnemies(dt) {
                const now = performance.now();
                const enemiesToRemove = [];

                this.enemies.forEach(enemy => {
                    enemy.progress += dt / enemy.duration;

                    const currentY = 45 - (enemy.progress * 80); 
                    const currentScale = 0.5 + (Math.pow(enemy.progress, 2) * 2.0); 
                    const maxOffset = 60; 
                    const directionMultiplier = enemy.side === 'left' ? -1 : 1;
                    const xOffset = (enemy.progress * maxOffset) * directionMultiplier;

                    enemy.el.style.bottom = `${currentY}%`;
                    enemy.el.style.transform = `translate(calc(-50% + ${xOffset}vw), 0) scale(${currentScale})`;
                    enemy.el.style.zIndex = Math.floor(enemy.progress * 150);

                    if (!enemy.hasSpoken && enemy.progress > 0.2) {
                        this.showDialogue(enemy);
                        enemy.hasSpoken = true;
                    }

                    const timeSinceSpawn = now - enemy.spawnTime;
                    if (timeSinceSpawn > 2000 && enemy.progress < 1.0) {
                        const isSafe = (this.player.isDodging && this.player.dodgeDirection !== enemy.side) || this.player.invincible;
                        
                        if (!isSafe) {
                            if (!enemy.collisionStarted) {
                                enemy.collisionStarted = now;
                            }
                            if (now - enemy.collisionStarted > 1000) {
                                this.handleCollision();
                                enemy.collisionStarted = now; 
                            }
                        } else {
                            enemy.collisionStarted = 0; 
                        }
                    }

                    if (enemy.progress >= 1.1) {
                        enemiesToRemove.push(enemy);
                        if(this.state === 'playing') {
                            this.score++;
                            this.updateScoreUI();
                        }
                    }
                });

                enemiesToRemove.forEach(enemy => {
                    if (enemy.el && enemy.el.parentNode) enemy.el.parentNode.removeChild(enemy.el);
                    const idx = this.enemies.indexOf(enemy);
                    if (idx > -1) this.enemies.splice(idx, 1);
                });
            },

            showDialogue(enemy) {
                const list = DIALOGUES[enemy.type];
                let availableTexts = list.filter(t => t !== this.lastEnemyDialogue[enemy.type]);
                if (availableTexts.length === 0) availableTexts = list;
                
                const text = availableTexts[Math.floor(Math.random() * availableTexts.length)];
                this.lastEnemyDialogue[enemy.type] = text;

                const bubble = document.createElement('div');
                bubble.className = 'bubble enemy-bubble';
                bubble.innerText = text;
                enemy.el.appendChild(bubble);
                
                setTimeout(() => bubble.style.opacity = 1, 50);
                
                setTimeout(() => {
                    bubble.style.opacity = 0;
                    setTimeout(() => bubble.remove(), 300);
                }, 3000);
            },

            handleCollision() {
                this.lives--;
                this.updateLivesUI();
                this.triggerDamageEffect();
                this.showPlayerHurtDialogue();
                this.setInvincible(true, 2000, true); 
                
                this.lastHurtTime = performance.now();

                if (this.lives <= 0) {
                    setTimeout(() => this.gameOver(), 800);
                }
            },

            showPlayerHurtDialogue() {
                let availableTexts = PLAYER_HURT_DIALOGUES.filter(t => t !== this.lastPlayerHurtDialogue);
                if (availableTexts.length === 0) availableTexts = PLAYER_HURT_DIALOGUES;
                
                const text = availableTexts[Math.floor(Math.random() * availableTexts.length)];
                this.lastPlayerHurtDialogue = text;
                this.showPlayerBubble(text, true);
            },

            showPlayerIdleDialogue() {
                let availableTexts = PLAYER_IDLE_DIALOGUES.filter(t => t !== this.lastPlayerIdleDialogue);
                if (availableTexts.length === 0) availableTexts = PLAYER_IDLE_DIALOGUES;

                const text = availableTexts[Math.floor(Math.random() * availableTexts.length)];
                this.lastPlayerIdleDialogue = text;
                this.showPlayerBubble(text, false);
            },

            showPlayerBubble(text, isDamage = true) {
                if (!this.player.el) return;
                
                const old = this.player.el.querySelector('.player-bubble');
                if (old) old.remove();

                this.player.isBubbleActive = true;

                const bubble = document.createElement('div');
                bubble.className = 'bubble player-bubble';
                if (!isDamage) {
                    bubble.style.borderColor = '#4a90e2';
                    bubble.style.color = '#4a90e2';
                    bubble.style.animation = 'none';
                }
                bubble.innerText = text;
                this.player.el.appendChild(bubble);

                setTimeout(() => bubble.style.opacity = 1, 10);
                setTimeout(() => {
                    bubble.style.opacity = 0;
                    setTimeout(() => {
                        if (bubble.parentNode) bubble.remove();
                        if (this.player.el && !this.player.el.querySelector('.player-bubble')) {
                            this.player.isBubbleActive = false;
                        }
                    }, 300);
                }, 2000);
            },

            triggerDamageEffect() {
                const overlay = document.getElementById('damage-overlay');
                overlay.style.opacity = 0.7;
                setTimeout(() => overlay.style.opacity = 0, 150);
            },

            setInvincible(state, duration = 0, visualEffect = true) {
                if (this.player.invincibleTimer) clearTimeout(this.player.invincibleTimer);
                if (!this.player.el) return;

                this.player.invincible = state;
                if (state) {
                    if (visualEffect) {
                        this.player.el.classList.add('invincible');
                    } else {
                        this.player.el.classList.remove('invincible');
                    }
                    
                    if (duration > 0) {
                        this.player.invincibleTimer = setTimeout(() => {
                            this.player.invincible = false;
                            if (this.player.el) this.player.el.classList.remove('invincible');
                        }, duration);
                    }
                } else {
                    this.player.el.classList.remove('invincible');
                }
            },

            updateScoreUI() { document.getElementById('score-val').innerText = this.score; },
            updateLivesUI() {
                let hearts = '';
                for(let i=0; i<this.lives; i++) hearts += 'â¤ï¸';
                document.getElementById('lives-container').innerText = hearts;
            },

            dodge(direction) {
                if (this.player.isDodging && this.player.dodgeDirection === direction) return;
                
                this.player.isDodging = true;
                this.player.dodgeDirection = direction;
                
                this.playRandomDodgeSound();

                this.setInvincible(true, 5000, false);

                if (!this.player.isBubbleActive && Math.random() < 0.1) {
                    const messages = ["ìŠ‰!", "ìŠˆìŠ‰!", "ìŠˆìŠ‰ìŠ‰!", "í›—!"];
                    const msg = messages[Math.floor(Math.random() * messages.length)];
                    this.showPlayerBubble(msg, false);
                }

                const imgList = direction === 'left' ? ASSETS.dodgeLeft : ASSETS.dodgeRight;
                this.updatePlayerImage(imgList[Math.floor(Math.random() * imgList.length)]);

                const moveAmount = direction === 'left' ? -15 : 15; 
                this.player.el.style.transform = `translateX(calc(-50% + ${moveAmount}vw))`;

                if (this.player.dodgeTimer) clearTimeout(this.player.dodgeTimer);
                this.player.dodgeTimer = setTimeout(() => {
                    this.player.isDodging = false;
                    this.player.dodgeDirection = null;
                    this.updatePlayerImage(ASSETS.run);
                    if (this.player.el) this.player.el.style.transform = `translateX(-50%)`;
                }, 700);
            }
        };

        window.onload = () => Game.init();
    </script>
</body>
</html>
